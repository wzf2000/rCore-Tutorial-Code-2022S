## OS Lab1 实验报告

<h4>王哲凡 计93 2019011200</h4>

### 实现功能

本次实验要求增加一个系统调用完成获取任务信息，为此我分别实现了：

- `TaskControlBlock` 中添加字段记录任务的各种系统调用次数与任务开始运行时间。
- 在 `TaskManager` 中运行任务时，根据是否设置过开始时间来进行开始运行时间的设置。
- 在 `syscall()` 中根据 `syscall_id` 对对应的系统调用次数加一。

### 问答题

#### 第 1 题

SBI 的版本为 `RustSBI version 0.2.0-alpha.4`，对应 `QEMU` 实现 `RustSBI-QEMU Version 0.0.1`：

```
[rustsbi] RustSBI version 0.2.0-alpha.4
.______       __    __      _______.___________.  _______..______   __
|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |
|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |
|      /     |  |  |  |    \   \       |  |      \   \    |   _  < |  |
|  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |
| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|

[rustsbi] Implementation: RustSBI-QEMU Version 0.0.1
```

三个测例的出错日志为：

```
[ERROR] [kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x8040008a, core dumped.
[ERROR] [kernel] IllegalInstruction in application, core dumped.
[ERROR] [kernel] IllegalInstruction in application, core dumped.
```

其错误原因分别是：

- 对于非法地址的访问，导致产生 Page Fault 即缺页异常。
- U 态调用 S 态特权指令 `sret`，导致产生非法指令异常。
- U 态调用 S/M 态特权指令 `csrr` 访问 `S` 态 CSR `sstatus`，导致产生非法指令异常。

#### 第 2 题

##### 第 (1) 问

刚进入 `__restore` 时，`a0` 代表了内核栈的栈顶（也即存储当前任务内核栈和通用寄存器的地址）。

两种使用场景为：

- 在 `run_next_task()` 时，需要进行各个应用之间进行切换，用于恢复一个已经开始过的任务的上下文。
- 在 `run_first_task()` 和 `run_next_task()` 时，需要开始各任务，用于初始化构造各任务的上下文。

##### 第 (2) 问

特殊处理了 S 态 CSR `sstatus`、`sepc`、`sscratch`。

他们的意义分别是：

- `sstatus`：记录了下一个任务运行在的特权级（即 U 态），发生异常的原因，此处后续用于 `sret` 正常返回 U 态。
- `sepc`：原来记录了 U 态下异常发生时的 `pc` 值，此处用于记录返回 U 态时执行指令的入口地址（第一条指令地址）。
- `sscratch`：在开始处理异常时，保存了用户栈栈顶（用户栈对应的 `sp`），后面用于与 `sp` 互换，恢复下一个任务的用户栈状态，再返回 U 态。

##### 第 (3) 问

`x2` 即 `sp`，后续会通过 `csrrw` 指令与 `sscratch` 互换保存（交换内核栈与用户栈），因此此处无需保存。

`x4` 即 `tp`，由于其在应用中一般不会使用，因此也可以不做保存。

##### 第 (4) 问

该指令后，`sp` 指向用户栈栈顶，`sscratch` 指向内核栈栈顶。

##### 第 (5) 问

发生状态切换是在指令 `sret`，此指令会根据 S 态 CSR `sstatus` 中记录的原特权级别信息（即 `SPP`），改变当前特权级（也即改为 U 态），并且将 `pc` 修改为 S 态 CSR `sepc` 中记录的值使得 CPU 恢复到用户态的对应指令继续执行。

##### 第 (6) 问

该指令后，`sp` 指向内核栈栈顶，`sscratch` 指向用户栈栈顶。

##### 第 (7) 问

进入 S 态在 U 态发生异常/中断的那条指令时发生，具体到用户态程序，可认为是执行每一个 `ecall`、发生时钟中断时的指令或非法访问内存指令、非法指令本身的时候发生的，也即在 L16 `__switch` 的第一条指令 `sd sp, 8(a0)` 之前已经发生。

### 建议

在 `src/timer.rs` 中的 `get_time_us()` 函数中，未考虑到 `CLOCK_FREQ` 不是 `MICRO_PER_SEC` 的整数倍，却用到了整除，这似乎会导致实际计算得到的微秒数值有误。

如果在计算毫秒时，也使用类似的表达式，会导致计算结果不一致无法通过测例。
